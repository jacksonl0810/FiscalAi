// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String  @id @default(uuid())
  email             String  @unique
  passwordHash      String? @map("password_hash") // Optional for Google auth users
  name              String
  avatar            String?
  
  // Stripe customer ID (replaces pagarMeCustomerId)
  stripeCustomerId  String? @unique @map("stripe_customer_id")
  
  cpfCnpj           String? @map("cpf_cnpj")
  phone             String? // Phone number for payment provider
  isAdmin           Boolean @default(false) @map("is_admin")

  // Billing address (required by payment providers for credit card payments)
  addressLine1      String? @map("address_line_1")
  addressLine2      String? @map("address_line_2")
  city              String?
  state             String? @db.Char(2) // Two-letter state code (e.g., SP, RJ)
  zipCode           String? @map("zip_code")

  // Google OAuth fields
  googleId      String? @unique @map("google_id")
  emailVerified Boolean @default(false) @map("email_verified")
  authProvider  String  @default("email") @map("auth_provider") // 'email' or 'google'

  // Legacy trial tracking fields (kept for data compatibility)
  hasUsedTrial   Boolean   @default(false) @map("has_used_trial")
  trialStartedAt DateTime? @map("trial_started_at")
  trialEndedAt   DateTime? @map("trial_ended_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  companies                 Company[]
  notifications             Notification[]
  settings                  UserSettings?
  refreshTokens             RefreshToken[]
  passwordResetTokens       PasswordResetToken[]
  emailVerificationTokens   EmailVerificationToken[]
  subscription              Subscription?
  conversationMessages      ConversationMessage[]
  invoiceUsages             InvoiceUsage[]
  accountantReviews         AccountantReview[]
  clients                   Client[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

model Company {
  id                           String    @id @default(uuid())
  userId                       String    @map("user_id")
  cnpj                         String    // Not globally unique - same CNPJ can exist for different users
  razaoSocial                  String    @map("razao_social")
  nomeFantasia                 String?   @map("nome_fantasia")
  cidade                       String
  uf                           String    @db.Char(2)
  cnaePrincipal                String?   @map("cnae_principal")
  regimeTributario             String    @map("regime_tributario")
  certificadoDigital           Boolean   @default(false) @map("certificado_digital")
  certificateUploadedToNuvemFiscal Boolean @default(false) @map("certificate_uploaded_to_nuvem_fiscal") // true only when upload to Nuvem Fiscal succeeded
  municipalCredentialsConfigured Boolean @default(false) @map("municipal_credentials_configured") // true when municipal credentials sent to Nuvem Fiscal
  email                        String
  telefone                     String
  inscricaoMunicipal           String    @map("inscricao_municipal")
  nuvemFiscalId                String?   @map("nuvem_fiscal_id")
  // Address fields required by Nuvem Fiscal
  cep                          String?   @map("cep")
  logradouro                   String?   @map("logradouro")
  numero                       String?   @map("numero")
  bairro                       String?   @map("bairro")
  codigoMunicipio              String?   @map("codigo_municipio")
  // Municipality support status
  municipalitySupported        Boolean?  @map("municipality_supported")
  municipalitySupportCheckedAt DateTime? @map("municipality_support_checked_at")
  // Fiscal connection status
  fiscalConnectionStatus       String    @default("not_connected") @map("fiscal_connection_status") // 'connected', 'not_connected', 'failed', 'expired'
  fiscalConnectionError        String?   @map("fiscal_connection_error")
  lastConnectionCheck          DateTime? @map("last_connection_check")
  createdAt                    DateTime  @default(now()) @map("created_at")
  updatedAt                    DateTime  @updatedAt @map("updated_at")

  // Relations
  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoices                Invoice[]
  dasPayments             DAS[]
  fiscalIntegrationStatus FiscalIntegrationStatus?
  accountantReviews       AccountantReview[]
  userSettings            UserSettings[]
  invoiceUsages           InvoiceUsage[]
  fiscalCredential        FiscalCredential?
  invoiceRetryQueue       InvoiceRetryQueue[]

  @@unique([userId, cnpj]) // Same user can't register same CNPJ twice, but different users CAN
  @@index([cnpj]) // Index for looking up by CNPJ across all users
  @@map("companies")
}

model Invoice {
  id                String    @id @default(uuid())
  companyId         String    @map("company_id")
  numero            String?
  clienteNome       String    @map("cliente_nome")
  clienteDocumento  String    @map("cliente_documento")
  descricaoServico  String    @map("descricao_servico")
  valor             Decimal   @db.Decimal(15, 2)
  aliquotaIss       Decimal   @default(5) @map("aliquota_iss") @db.Decimal(5, 2)
  valorIss          Decimal?  @map("valor_iss") @db.Decimal(15, 2)
  issRetido         Boolean   @default(false) @map("iss_retido")
  status            String    @default("rascunho")
  municipio         String?
  codigoVerificacao String?   @map("codigo_verificacao")
  dataEmissao       DateTime? @map("data_emissao") @db.Date
  dataPrestacao     DateTime? @map("data_prestacao") @db.Date
  codigoServico     String?   @map("codigo_servico")
  pdfUrl            String?   @map("pdf_url")
  xmlUrl            String?   @map("xml_url")
  nuvemFiscalId     String?   @map("nuvem_fiscal_id")
  paymentStatus     String?   @default("pending") @map("payment_status")
  paymentOrderId    String?   @map("payment_order_id")
  invoiceUsageId    String?   @unique @map("invoice_usage_id")
  lastStatusCheckAt DateTime? @map("last_status_check_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  company           Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  notifications     Notification[]
  invoiceUsage      InvoiceUsage?          @relation("InvoiceUsageInvoice")
  statusHistory     InvoiceStatusHistory[]
  accountantReviews AccountantReview[]

  @@map("invoices")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  titulo    String
  mensagem  String
  tipo      String // 'sucesso', 'erro', 'alerta', 'info'
  lida      Boolean  @default(false)
  invoiceId String?  @map("invoice_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoice Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@map("notifications")
}

model UserSettings {
  id              String   @id @default(uuid())
  userId          String   @unique @map("user_id")
  theme           String   @default("dark")
  fontSize        String   @default("medium") @map("font_size")
  activeCompanyId String?  @map("active_company_id")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeCompany Company? @relation(fields: [activeCompanyId], references: [id], onDelete: SetNull)

  @@map("user_settings")
}

model DAS {
  id             String    @id @default(uuid())
  companyId      String    @map("company_id")
  referencia     String // e.g., '01/2025'
  dataVencimento DateTime  @map("data_vencimento") @db.Date
  valorTotal     Decimal   @map("valor_total") @db.Decimal(15, 2)
  valorInss      Decimal?  @map("valor_inss") @db.Decimal(15, 2)
  valorIcms      Decimal?  @map("valor_icms") @db.Decimal(15, 2)
  valorIss       Decimal?  @map("valor_iss") @db.Decimal(15, 2)
  status         String    @default("pendente") // 'pendente', 'pago'
  codigoBarras   String?   @map("codigo_barras")
  pdfUrl         String?   @map("pdf_url")
  dataPagamento  DateTime? @map("data_pagamento") @db.Date
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("das")
}

model FiscalIntegrationStatus {
  id                String    @id @default(uuid())
  companyId         String    @unique @map("company_id")
  status            String    @default("verificando") // 'conectado', 'falha', 'verificando'
  mensagem          String?
  ultimaVerificacao DateTime? @map("ultima_verificacao")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("fiscal_integration_status")
}

model Subscription {
  id                   String             @id @default(uuid())
  userId               String             @unique @map("user_id")
  planId               String             @default("pay_per_use") @map("plan_id") // 'pay_per_use', 'essential', 'professional', 'accountant'
  
  // Stripe subscription and price IDs (replaces Pagar.me fields)
  stripeSubscriptionId String?            @unique @map("stripe_subscription_id")
  stripePriceId        String?            @map("stripe_price_id")
  
  status               SubscriptionStatus @default(PENDING) // Strict enum for subscription lifecycle
  billingCycle         String?            @map("billing_cycle") // 'monthly', 'semiannual', 'annual'
  annualDiscountApplied Boolean           @default(false) @map("annual_discount_applied")
  currentPeriodStart   DateTime?          @map("current_period_start")
  currentPeriodEnd     DateTime?          @map("current_period_end")
  nextBillingAt        DateTime?          @map("next_billing_at") // Next billing date for recurring subscriptions
  canceledAt           DateTime?          @map("canceled_at")
  trialEndsAt          DateTime?          @map("trial_ends_at")
  createdAt            DateTime           @default(now()) @map("created_at")
  updatedAt            DateTime           @updatedAt @map("updated_at")

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@index([nextBillingAt, status])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

enum SubscriptionStatus {
  PENDING    // Created, first invoice not paid yet
  ACTIVE     // Last invoice paid, subscription active
  PAST_DUE   // Payment failed, retry pending
  CANCELED   // Canceled by user or system
  EXPIRED    // End date reached (optional)
}

model Payment {
  id                String        @id @default(uuid())
  subscriptionId    String        @map("subscription_id")
  
  // Stripe invoice ID (nullable to preserve existing Pagar.me data)
  stripeInvoiceId   String?       @unique @map("stripe_invoice_id")
  
  amount            Decimal       @db.Decimal(15, 2)
  status            PaymentStatus // Strict enum for payment status
  paymentMethod     String        @map("payment_method") // 'credit_card', 'boleto', 'pix'
  paidAt            DateTime?     @map("paid_at")
  failedAt          DateTime?     @map("failed_at")
  failureReason     String?       @map("failure_reason") // Gateway error message
  nfseId            String?       @map("nfse_id") // Link to fiscal invoice
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@map("payments")
}

enum PaymentStatus {
  PAID
  FAILED
}

model ConversationMessage {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  role      String // 'user' or 'assistant'
  content   String   @db.Text
  metadata  Json? // Store action data, timestamps, etc.
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("conversation_messages")
}

model InvoiceUsage {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  companyId      String?  @map("company_id") // null for pay-per-use (not company-specific)
  invoiceId      String?  @unique @map("invoice_id") // null if payment pending
  planId         String   @map("plan_id")
  periodYear     Int      @map("period_year")
  periodMonth    Int      @map("period_month")
  amount         Int // Amount in cents (R$9 = 900 cents for pay-per-use)
  status         String   @default("pending_payment") // 'pending_payment', 'paid', 'failed'
  paymentOrderId String?  @map("payment_order_id") // Pagar.me order ID for pay-per-use
  createdAt      DateTime @default(now()) @map("created_at")

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoice Invoice? @relation("InvoiceUsageInvoice", fields: [invoiceId], references: [id], onDelete: SetNull)

  @@index([userId, periodYear, periodMonth])
  @@index([companyId, periodYear, periodMonth])
  @@map("invoice_usage")
}

model FiscalCredential {
  id            String    @id @default(uuid())
  companyId     String    @unique @map("company_id")
  type          String    @map("type") // 'certificate', 'municipal_credentials'
  encryptedData String    @map("encrypted_data") // Encrypted certificate/credentials (base64)
  metadata      Json? // Additional metadata (expiration, username hint, etc.)
  expiresAt     DateTime? @map("expires_at")
  lastUsedAt    DateTime? @map("last_used_at")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("fiscal_credentials")
}

model InvoiceStatusHistory {
  id        String   @id @default(uuid())
  invoiceId String   @map("invoice_id")
  status    String
  message   String?
  source    String // 'api', 'webhook', 'manual', 'polling'
  metadata  Json? // Additional context
  createdAt DateTime @default(now()) @map("created_at")

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId, createdAt])
  @@map("invoice_status_history")
}

model AccountantReview {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  invoiceId       String?   @map("invoice_id") // Optional - can review before invoice creation
  companyId       String    @map("company_id")
  status          String    @default("pending") // 'pending', 'in_review', 'approved', 'rejected', 'completed'
  reviewType      String    @map("review_type") // 'pre_issuance', 'post_issuance', 'correction'
  documents       Json? // Array of document metadata (name, url, type)
  notes           String? // User notes/instructions for accountant
  accountantNotes String?   @map("accountant_notes") // Accountant's review notes
  requestedAt     DateTime  @default(now()) @map("requested_at")
  reviewedAt      DateTime? @map("reviewed_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoice Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([companyId, status])
  @@index([invoiceId])
  @@map("accountant_reviews")
}

// Invoice retry queue for municipality offline scenarios
model InvoiceRetryQueue {
  id          String    @id @default(uuid())
  companyId   String    @map("company_id")
  userId      String    @map("user_id")
  invoiceData Json      @map("invoice_data") // Full invoice data to emit
  status      String    @default("pending") // 'pending', 'processing', 'completed', 'failed'
  reason      String? // Why it was queued
  attempts    Int       @default(0)
  lastError   String?   @map("last_error")
  nextRetryAt DateTime? @map("next_retry_at")
  invoiceId   String?   @map("invoice_id") // Set when successfully completed
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([status, nextRetryAt])
  @@index([companyId, status])
  @@index([userId])
  @@map("invoice_retry_queue")
}

// Municipality support cache for NFS-e coverage
model MunicipalityCache {
  id        String   @id @default(uuid())
  key       String   @unique // e.g., 'supported_cities', 'municipality_3550308'
  value     String   @db.Text // JSON stringified data
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([key])
  @@index([expiresAt])
  @@map("municipality_cache")
}

// Client/Customer model - invoice recipients (tomador)
// Belongs to the user account, can be used across all user's companies
model Client {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  
  // Identification
  nome      String   // Full name (PF) or business name (PJ)
  documento String   // CPF (PF) or CNPJ (PJ)
  tipoPessoa String  @default("pf") @map("tipo_pessoa") // 'pf' (pessoa física) or 'pj' (pessoa jurídica)
  
  // Contact info
  email     String?
  telefone  String?
  
  // Address (optional but useful for some municipalities)
  cep           String?
  logradouro    String?
  numero        String?
  complemento   String?
  bairro        String?
  cidade        String?
  uf            String? @db.Char(2)
  codigoMunicipio String? @map("codigo_municipio") // IBGE code
  
  // Metadata
  apelido   String?  // User-friendly nickname for quick reference (e.g., "Gabriel", "Dr. Silva")
  notas     String?  @db.Text // Internal notes about the client
  ativo     Boolean  @default(true) // Soft delete / archive
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, ativo])
  @@index([userId, documento])
  @@index([userId, nome])
  @@map("clients")
}
